---
description: ARK 服务器管理器 - 基于 Nuxt.js + Gin + Gorm 的前后端分离 ARK 服务器管理系统
globs: ["**/*"]
alwaysApply: true
---
# ARK 服务器管理器 - Cursor AI 助手配置

## 项目概述
这是一个基于 Nuxt.js 3 + Gin + Gorm 的前后端分离 ARK 服务器管理系统，部署在单一 Docker 镜像中。

### 技术栈
- **前端**: Nuxt.js 3 + Pinia + Tailwind CSS + Nuxt UI
- **后端**: Gin + Gorm + SQLite + JWT
- **数据库**: SQLite
- **认证**: JWT + bcrypt
- **部署**: Docker 单镜像部署
- **国际化**: Nuxt i18n (中文/英文)

## 项目结构
```
ArkServerManager/
├── server/              # 后端 Go 代码
│   ├── config/          # 配置管理
│   ├── controllers/     # 控制器层
│   ├── database/        # 数据库连接
│   ├── middleware/      # 中间件
│   ├── models/          # 数据模型
│   ├── routes/          # 路由定义
│   ├── service/         # 业务服务层
│   │   └── docker_manager/  # Docker 管理服务
│   └── utils/           # 工具函数
├── ui/                  # 前端 Nuxt.js 代码
│   ├── app/             # Nuxt 应用主目录
│   │   ├── assets/      # 静态资源
│   │   ├── components/  # Vue 组件
│   │   │   ├── dockerimages/    # Docker 镜像相关组件
│   │   │   └── servers/         # 服务器相关组件
│   │   ├── layouts/     # 页面布局
│   │   ├── middleware/  # 前端中间件
│   │   ├── pages/       # 页面组件
│   │   ├── plugins/     # 插件
│   │   ├── stores/      # Pinia 状态管理
│   │   └── utils/       # 前端工具函数
│   ├── i18n/            # 国际化配置
│   │   └── locales/     # 语言文件
│   ├── public/          # 公共静态文件
│   └── server/          # 服务端渲染配置
├── docs/                # 项目文档
├── Dockerfile           # 单镜像构建
├── docker-compose.yml   # Docker 编排
└── start-dev-*.bat      # 开发启动脚本
```

## 代码规范

### Go 后端规范
- 使用 `gofmt` 格式化代码
- 函数名使用驼峰命名法，公开函数首字母大写
- 错误处理必须显式检查，不能忽略 error
- API 响应格式：成功 `{"message": "成功信息", "data": {}}`，错误 `{"error": "错误信息"}`
- 控制器函数接收 `*gin.Context` 参数
- 数据库模型使用 gorm 标签

### 后端架构分层规范

#### 控制层（Controllers）职责
控制层位于 `server/controllers/` 目录，专注于 HTTP 请求和响应处理：

- **主要职责**：
  - HTTP 请求参数解析和验证
  - 调用业务层服务方法
  - HTTP 响应格式化和状态码设置
  - 路由处理和中间件集成
  - 请求上下文传递（用户认证信息等）

- **代码规范**：
  - 控制器函数必须接收 `*gin.Context` 参数
  - 使用 `ShouldBindJSON()` 进行请求体绑定
  - 使用 `c.GetUint("user_id")` 获取用户身份信息
  - 统一使用 `gin.H` 构建响应 JSON
  - 根据业务层返回的错误类型设置合适的 HTTP 状态码

- **禁止行为**：
  - 不得直接操作数据库
  - 不得包含复杂的业务逻辑
  - 不得直接调用第三方服务
  - 不得进行数据转换和处理（除基本的请求响应格式化）

- **错误处理模式**：
```go
func ExampleController(c *gin.Context) {
    userID := c.GetUint("user_id")
    
    var req RequestModel
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "请求参数错误"})
        return
    }
    
    result, err := service.ExampleMethod(userID, req)
    if err != nil {
        // 根据错误类型返回不同状态码
        if err.Error() == "记录不存在" {
            c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
            return
        }
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "message": "操作成功",
        "data": result,
    })
}
```

#### 业务层（Service）职责
业务层位于 `server/service/` 目录，专注于业务逻辑处理：

- **主要职责**：
  - 核心业务逻辑实现
  - 数据验证和处理
  - 数据库事务管理
  - 第三方服务集成
  - 数据转换和格式化
  - 异步任务处理

- **代码规范**：
  - 服务结构体使用 `Service` 后缀命名
  - 提供 `New{Service}()` 构造函数
  - 方法返回值包含错误信息：`(result, error)`
  - 使用有意义的错误消息，便于控制层判断
  - 复杂操作使用数据库事务

- **目录结构**：
```
service/
├── server/
│   └── server_service.go    # 服务器管理业务逻辑
├── docker_manager/
│   └── docker_manager.go    # Docker 管理服务
└── user/
    └── user_service.go      # 用户管理业务逻辑
```

- **服务层模式**：
```go
type ExampleService struct{}

func NewExampleService() *ExampleService {
    return &ExampleService{}
}

func (s *ExampleService) ExampleMethod(userID uint, req RequestModel) (*ResponseModel, error) {
    // 参数验证
    if req.RequiredField == "" {
        return nil, fmt.Errorf("必填参数不能为空")
    }
    
    // 业务逻辑处理
    // ...
    
    // 数据库操作
    tx := database.DB.Begin()
    if tx.Error != nil {
        return nil, fmt.Errorf("数据库事务启动失败: %w", tx.Error)
    }
    
    // 业务处理
    if err := tx.Create(&model).Error; err != nil {
        tx.Rollback()
        return nil, fmt.Errorf("数据创建失败: %w", err)
    }
    
    if err := tx.Commit().Error; err != nil {
        return nil, fmt.Errorf("事务提交失败: %w", err)
    }
    
    return &result, nil
}
```

#### 层间交互规范

- **依赖方向**：
  - 控制层 → 业务层 → 数据层
  - 上层可以调用下层，下层不得直接调用上层
  - 同层之间可以相互调用，但要避免循环依赖

- **数据传递**：
  - 使用模型（models）进行层间数据传递
  - 控制层传递请求模型给业务层
  - 业务层返回响应模型给控制层

- **错误传递**：
  - 业务层返回有意义的错误信息
  - 控制层根据错误信息判断 HTTP 状态码
  - 使用 `fmt.Errorf` 包装错误，保留调用栈

- **事务管理**：
  - 数据库事务在业务层管理
  - 控制层不直接操作数据库事务
  - 复杂业务操作必须使用事务确保数据一致性

#### 服务初始化规范

- **全局服务实例**：
```go
// 在控制器包中初始化服务实例
var serverService = server.NewServerService()
var userService = user.NewUserService()
```

- **服务依赖注入**：
  - 服务层可以依赖其他服务
  - 通过构造函数传递依赖的服务实例
  - 避免在方法内部创建服务实例

- **单例模式**：
  - 服务实例通常使用单例模式
  - 避免频繁创建和销毁服务实例
  - 确保服务实例的线程安全

#### 异步处理规范

- **后台任务**：
  - 使用 goroutine 处理长时间运行的任务
  - 在业务层实现异步逻辑
  - 确保异步任务的错误处理和日志记录

- **状态管理**：
  - 异步任务的状态更新在业务层处理
  - 使用数据库记录任务状态
  - 提供任务状态查询接口

### Vue/JavaScript 前端规范
- 使用 Composition API (setup script)
- 组件文件名使用 PascalCase (MyComponent.vue)
- 页面文件名使用 kebab-case (my-page.vue)
- 使用 Pinia 进行状态管理
- Tailwind CSS 进行样式设计
- 使用 Vue 3 响应式 API (ref, reactive, computed)

### 前端页面布局和组件规范
- **优先使用 Nuxt UI 组件**：尽可能使用 `@nuxt/ui` 提供的预构建组件，减少自定义 HTML 元素的使用
- **减少 `<div>` 使用**：避免不必要的 `<div>` 包装，使用语义化的 HTML 元素和 Nuxt UI 组件
- **布局组件优先级**：
  - 使用 `UContainer` 替代普通的容器 div
  - 使用 `UCard` 替代自定义卡片布局
  - 使用 `UButton` 替代原生 button
  - 使用 `UInput`, `UTextarea`, `USelect` 等表单组件
  - 使用 `UModal`, `UAlert`, `UNotification` 等交互组件
  - 使用 `UTable`, `UPagination` 等数据展示组件
- **栅格系统**：使用 Nuxt UI 的 `UContainer` 和 Tailwind 的 flex/grid 系统进行布局
- **主题一致性**：统一使用 Nuxt UI 的主题系统，确保视觉风格一致
- **响应式设计**：结合 Nuxt UI 组件的响应式特性和 Tailwind 的响应式工具类
- **无障碍访问**：利用 Nuxt UI 组件内置的无障碍访问特性
- **组件组合**：通过组合 Nuxt UI 的基础组件来构建复杂界面，而不是使用大量 div 嵌套

### 国际化 (i18n) 规范
- 使用 Nuxt i18n 模块进行国际化
- 语言文件位于 `ui/i18n/locales/` 目录
- 支持中文 (zh) 和英文 (en) 两种语言
- 使用 `$t()` 函数在模板中访问翻译
- 使用 `useI18n()` 在 script 中访问翻译
- 翻译键使用点号分隔的层级结构 (如 `servers.title`)
- 所有用户可见的文本必须使用翻译键
- 翻译文件按功能模块组织 (common, auth, servers, home 等)
- 动态内容使用插值语法 `{variable}` 进行参数替换
- 语言切换使用 `setLocale()` 方法
- 翻译键命名使用小写字母和点号分隔
- 避免在翻译文本中包含 HTML 标签
- 复数形式使用条件判断处理
- 日期、数字格式化使用 i18n 提供的格式化函数

## 开发约定

### API 设计
- RESTful API 设计原则
- 使用 HTTP 状态码表示请求结果
- 认证使用 Bearer Token 格式
- API 路径使用小写和连字符

### 数据库
- 使用 Gorm 进行数据库操作
- 模型结构体包含标准字段：ID, CreatedAt, UpdatedAt, DeletedAt
- 数据库迁移使用 AutoMigrate
- 敏感数据使用 json:"-" 标签隐藏

### 错误处理
- 后端：统一的错误处理中间件
- 前端：使用 try-catch 处理异步操作
- 用户友好的错误信息显示

### i18n 错误处理和调试
- **翻译缺失**：使用 `$t('key', 'fallback')` 提供默认值
- **调试模式**：在开发环境中启用 i18n 调试模式
- **键名检查**：定期验证翻译键的存在性和完整性
- **类型安全**：使用 TypeScript 类型定义翻译键结构
- **性能优化**：避免在模板中使用复杂的翻译逻辑
- **缓存策略**：合理使用 i18n 的缓存机制
- **错误日志**：记录翻译相关的错误信息
- **回退机制**：为关键翻译提供多级回退策略

### 安全规范
- 密码使用 bcrypt 加密
- JWT token 设置合理的过期时间
- API 接口进行适当的权限验证
- 前端不存储敏感信息

### i18n 开发最佳实践
- **翻译键命名**：使用有意义的层级结构，如 `servers.addServer`、`auth.loginTitle`
- **翻译完整性**：确保所有语言文件包含相同的翻译键，避免缺失翻译
- **动态内容**：使用插值语法处理变量，如 `欢迎，{username}`
- **复数处理**：使用条件判断处理复数形式，如 `{count} 个服务器`
- **格式化**：使用 i18n 的日期、数字格式化功能
- **上下文**：为翻译键提供足够的上下文信息
- **测试**：定期检查翻译的完整性和准确性
- **命名空间**：按功能模块组织翻译，避免键名冲突
- **错误处理**：为翻译缺失提供友好的错误提示

### 前端代码质量规范
- **组件设计原则**：
  - 单一职责：每个组件只负责一个明确的功能
  - 可复用性：设计通用组件时考虑不同使用场景
  - 可测试性：组件逻辑清晰，便于单元测试
  - 可维护性：代码结构清晰，注释完整
- **Nuxt UI 组件使用规范**：
  - 禁止重复造轮子：优先使用 Nuxt UI 现有组件
  - 组件定制：通过 props 和 slots 定制 Nuxt UI 组件行为
  - 主题配置：统一在 `nuxt.config.ts` 中配置 UI 主题
  - 图标使用：使用 Nuxt UI 内置的 Heroicons 图标库
- **HTML 语义化规范**：
  - 使用适当的 HTML5 语义标签：`<header>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<aside>`, `<footer>`
  - 避免过度使用 `<div>` 和 `<span>`
  - 表单使用 `<form>`, `<fieldset>`, `<legend>` 等语义标签
  - 列表使用 `<ul>`, `<ol>`, `<li>` 标签
- **CSS 和样式规范**：
  - 优先使用 Tailwind CSS 工具类
  - 避免内联样式，使用 class 绑定
  - 组件样式使用 scoped CSS
  - 响应式设计使用 Tailwind 的响应式前缀
- **性能优化规范**：
  - 使用 `v-show` vs `v-if` 的合适场景
  - 大列表使用虚拟滚动组件
  - 图片使用 `<NuxtImg>` 组件进行优化
  - 路由懒加载和组件懒加载

## 部署规范
- 使用环境变量管理配置
- 单 Docker 镜像部署，包含前后端
- 健康检查接口
- 日志记录和监控

## Cursor AI 开发限制

### 执行环境限制
- **禁止启动服务进行测试验证**：由于 Cursor 无法在 Windows PowerShell 环境下正常运行和管理后台服务，AI 助手不得使用 `run_terminal_cmd` 工具启动前后端服务
- **禁止的命令包括但不限于**：
  - `go run main.go`
  - `npm run dev` 或 `pnpm dev`
  - `docker-compose up`
  - 任何可能启动长期运行服务的命令

### 替代验证方法
- 通过**静态代码分析**验证逻辑正确性
- 提供**问题排查指南**而不是直接运行测试
- 使用**代码审查**的方式确保修改的正确性

### 推荐的工作流程
1. **分析问题**：通过查看代码、日志、错误信息等方式定位问题
2. **修改代码**：进行必要的代码修改和优化
3. **代码审查**：通过静态分析确保修改的正确性
4. **问题预防**：提供可能遇到的问题和解决方案

### 命令使用原则
- 仅使用**只读性质**的终端命令（如 `cat`、`ls`、`grep` 等）
- 可以使用**静态检查**命令（如 `go build`、`npm install` 等不启动服务的命令）
- **严禁**使用任何可能启动服务或需要用户交互的命令

### i18n 相关工具和命令
- **翻译检查**：使用 `grep` 命令检查翻译键的使用情况
- **键名验证**：使用 `jq` 或类似工具验证翻译文件结构
- **缺失检测**：编写脚本检测翻译键的完整性
- **格式化**：使用 `prettier` 格式化翻译文件
- **类型检查**：使用 TypeScript 检查翻译键的类型安全
- **自动化**：使用 CI/CD 自动检查翻译完整性

这些限制确保了在 Cursor 环境下的稳定开发体验，避免因环境不兼容导致的问题。

## Git 提交规范

### Conventional Commits 标准
使用 [Conventional Commits](https://www.conventionalcommits.org/) 规范进行 Git 提交，格式如下：

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

### 提交类型 (type)
- **feat**: 新功能
- **fix**: 修复 bug
- **docs**: 文档更新
- **style**: 代码格式调整（不影响代码逻辑）
- **refactor**: 代码重构
- **perf**: 性能优化
- **test**: 测试相关
- **chore**: 构建过程或辅助工具的变动
- **ci**: CI/CD 相关变更
- **build**: 构建系统或外部依赖变更

### 作用域 (scope)
可选，用于说明提交影响的范围：
- **frontend**: 前端相关
- **backend**: 后端相关
- **database**: 数据库相关
- **docker**: Docker 相关
- **auth**: 认证相关
- **api**: API 接口相关
- **i18n**: 国际化相关

### 提交示例
```
feat(auth): 添加用户登录功能
fix(backend): 修复服务器启动时的端口冲突问题
docs: 更新 README.md 安装说明
style(frontend): 统一按钮组件样式
refactor(api): 重构服务器管理 API 接口
perf(database): 优化数据库查询性能
test(backend): 添加用户认证单元测试
chore: 更新依赖包版本
ci: 配置 GitHub Actions 自动部署
build(docker): 优化 Docker 镜像构建过程
feat(i18n): 添加英文语言支持
fix(i18n): 修复翻译键缺失问题
```

### 提交规范要求
- 提交信息使用中文描述
- 类型和作用域使用英文
- 描述简洁明了，不超过 50 个字符
- 如果需要详细说明，在 body 中补充
- 关联 issue 时在 footer 中使用 `Closes #123` 格式

### 分支命名规范
- **feature/**: 新功能分支，如 `feature/user-auth`
- **fix/**: 修复分支，如 `fix/server-startup`
- **hotfix/**: 紧急修复分支，如 `hotfix/critical-bug`
- **docs/**: 文档分支，如 `docs/api-documentation`
- **refactor/**: 重构分支，如 `refactor/database-models`

### 工作流程
1. 从 `main` 分支创建功能分支
2. 在分支上进行开发和测试
3. 提交时遵循 Conventional Commits 规范
4. 创建 Pull Request 进行代码审查
5. 合并到 `main` 分支并删除功能分支

